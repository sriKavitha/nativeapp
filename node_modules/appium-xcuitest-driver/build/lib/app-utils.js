"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractBundleVersion = exports.isolateAppBundle = exports.findApps = exports.isAppBundle = exports.IPA_EXT = exports.APP_EXT = exports.fetchSupportedAppPlatforms = exports.SAFARI_BUNDLE_ID = exports.parseLocalizableStrings = exports.verifyApplicationPlatform = exports.extractBundleId = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("appium/support");
const logger_js_1 = __importDefault(require("./logger.js"));
const STRINGSDICT_RESOURCE = '.stringsdict';
const STRINGS_RESOURCE = '.strings';
const SAFARI_BUNDLE_ID = 'com.apple.mobilesafari';
exports.SAFARI_BUNDLE_ID = SAFARI_BUNDLE_ID;
const APP_EXT = '.app';
exports.APP_EXT = APP_EXT;
const IPA_EXT = '.ipa';
exports.IPA_EXT = IPA_EXT;
const PLIST_CACHE = new WeakMap();
/**
 * Retrieves the value of the given entry name from the application's Info.plist.
 *
 * @this {Object} Optinal instance used for caching. Ususally the driver instance.
 * @param {string} app Full path to the app bundle root.
 * @param {string} entryName Key name in the plist.
 * @returns {Promise<any | undefined>} Either the extracted value or undefined if no such key has been found in the plist.
 * @throws {Error} If the application's Info.plist cannot be parsed.
 */
async function extractPlistEntry(app, entryName) {
    const plistPath = path_1.default.resolve(app, 'Info.plist');
    const parseFile = async () => {
        try {
            return await support_1.plist.parsePlistFile(plistPath);
        }
        catch (err) {
            throw new Error(`Could not extract Info.plist from '${path_1.default.basename(app)}': ${err.message}`);
        }
    };
    let plistObj;
    if (lodash_1.default.isNil(this)) {
        plistObj = await parseFile();
    }
    else {
        plistObj = PLIST_CACHE.get(this)?.[app];
        if (!plistObj) {
            plistObj = await parseFile();
            PLIST_CACHE.set(this, {
                ...(PLIST_CACHE.get(this) || {}),
                [app]: plistObj,
            });
        }
    }
    return plistObj[entryName];
}
async function extractBundleId(app) {
    const bundleId = await extractPlistEntry.bind(this)(app, 'CFBundleIdentifier');
    logger_js_1.default.debug(`Getting bundle ID from app '${app}': '${bundleId}'`);
    return bundleId;
}
exports.extractBundleId = extractBundleId;
async function extractBundleVersion(app) {
    return await extractPlistEntry.bind(this)(app, 'CFBundleVersion');
}
exports.extractBundleVersion = extractBundleVersion;
async function fetchSupportedAppPlatforms(app) {
    try {
        const result = await extractPlistEntry.bind(this)(app, 'CFBundleSupportedPlatforms');
        if (!lodash_1.default.isArray(result)) {
            logger_js_1.default.warn(`${path_1.default.basename(app)}': CFBundleSupportedPlatforms is not a valid list`);
            return [];
        }
        return result;
    }
    catch (err) {
        logger_js_1.default.warn(`Cannot extract the list of supported platforms from '${path_1.default.basename(app)}': ${err.message}`);
        return [];
    }
}
exports.fetchSupportedAppPlatforms = fetchSupportedAppPlatforms;
/**
 * @typedef {Object} PlatformOpts
 *
 * @property {boolean} isSimulator - Whether the destination platform is a Simulator
 * @property {boolean} isTvOS - Whether the destination platform is a Simulator
 */
/**
 * Verify whether the given application is compatible to the
 * platform where it is going to be installed and tested.
 *
 * @param {string} app - The actual path to the application bundle
 * @param {PlatformOpts} expectedPlatform
 * @throws {Error} If bundle architecture does not match the expected device architecture.
 */
async function verifyApplicationPlatform(app, expectedPlatform) {
    logger_js_1.default.debug('Verifying application platform');
    const supportedPlatforms = await fetchSupportedAppPlatforms.bind(this)(app);
    logger_js_1.default.debug(`CFBundleSupportedPlatforms: ${JSON.stringify(supportedPlatforms)}`);
    const { isSimulator, isTvOS, } = expectedPlatform;
    const prefix = isTvOS ? 'AppleTV' : 'iPhone';
    const suffix = isSimulator ? 'Simulator' : 'OS';
    const dstPlatform = `${prefix}${suffix}`;
    if (!supportedPlatforms.includes(dstPlatform)) {
        throw new Error(`${isSimulator ? 'Simulator' : 'Real device'} architecture is unsupported by the '${app}' application. ` +
            `Make sure the correct deployment target has been selected for its compilation in Xcode.`);
    }
}
exports.verifyApplicationPlatform = verifyApplicationPlatform;
async function readResource(resourcePath) {
    const data = await support_1.plist.parsePlistFile(resourcePath);
    const result = {};
    for (const [key, value] of lodash_1.default.toPairs(data)) {
        result[key] = lodash_1.default.isString(value) ? value : JSON.stringify(value);
    }
    return result;
}
async function parseLocalizableStrings(opts) {
    const { app, language = 'en', localizableStringsDir, stringFile, strictMode, } = opts;
    if (!app) {
        const message = `Strings extraction is not supported if 'app' capability is not set`;
        if (strictMode) {
            throw new Error(message);
        }
        logger_js_1.default.info(message);
        return {};
    }
    let lprojRoot;
    for (const subfolder of [`${language}.lproj`, localizableStringsDir, '']) {
        lprojRoot = path_1.default.resolve(app, subfolder);
        if (await support_1.fs.exists(lprojRoot)) {
            break;
        }
        const message = `No '${lprojRoot}' resources folder has been found`;
        if (strictMode) {
            throw new Error(message);
        }
        logger_js_1.default.debug(message);
    }
    logger_js_1.default.info(`Will extract resource strings from '${lprojRoot}'`);
    const resourcePaths = [];
    if (stringFile) {
        const dstPath = path_1.default.resolve(String(lprojRoot), stringFile);
        if (await support_1.fs.exists(dstPath)) {
            resourcePaths.push(dstPath);
        }
        else {
            const message = `No '${dstPath}' resource file has been found for '${app}'`;
            if (strictMode) {
                throw new Error(message);
            }
            logger_js_1.default.info(message);
            logger_js_1.default.info(`Getting all the available strings from '${lprojRoot}'`);
        }
    }
    if (lodash_1.default.isEmpty(resourcePaths) && await support_1.fs.exists(String(lprojRoot))) {
        const resourceFiles = (await support_1.fs.readdir(String(lprojRoot)))
            .filter((name) => lodash_1.default.some([STRINGS_RESOURCE, STRINGSDICT_RESOURCE], (x) => name.endsWith(x)))
            .map((name) => path_1.default.resolve(lprojRoot, name));
        resourcePaths.push(...resourceFiles);
    }
    logger_js_1.default.info(`Got ${resourcePaths.length} resource file(s) in '${lprojRoot}'`);
    if (lodash_1.default.isEmpty(resourcePaths)) {
        return {};
    }
    const resultStrings = {};
    const toAbsolutePath = function (p) {
        return path_1.default.isAbsolute(p) ? p : path_1.default.resolve(process.cwd(), p);
    };
    for (const resourcePath of resourcePaths) {
        if (!support_1.util.isSubPath(toAbsolutePath(resourcePath), toAbsolutePath(app))) {
            // security precaution
            throw new Error(`'${resourcePath}' is expected to be located under '${app}'`);
        }
        try {
            const data = await readResource(resourcePath);
            logger_js_1.default.debug(`Parsed ${lodash_1.default.keys(data).length} string(s) from '${resourcePath}'`);
            lodash_1.default.merge(resultStrings, data);
        }
        catch (e) {
            logger_js_1.default.warn(`Cannot parse '${resourcePath}' resource. Original error: ${e.message}`);
        }
    }
    logger_js_1.default.info(`Got ${lodash_1.default.keys(resultStrings).length} string(s) from '${lprojRoot}'`);
    return resultStrings;
}
exports.parseLocalizableStrings = parseLocalizableStrings;
/**
 * Check whether the given path on the file system points to the .app bundle root
 *
 * @param {string} appPath Possible .app bundle root
 * @returns {Promise<boolean>} Whether the given path points to an .app bundle
 */
async function isAppBundle(appPath) {
    return lodash_1.default.endsWith(lodash_1.default.toLower(appPath), APP_EXT)
        && (await support_1.fs.stat(appPath)).isDirectory()
        && await support_1.fs.exists(path_1.default.join(appPath, 'Info.plist'));
}
exports.isAppBundle = isAppBundle;
/**
 * Extract the given archive and looks for items with given extensions in it
 *
 * @param {string} archivePath Full path to a .zip archive
 * @param {Array<string>} appExtensions List of matching item extensions
 * @returns {Promise<[string, string[]]>} Tuple, where the first element points to
 * a temporary folder root where the archive has been extracted and the second item
 * contains a list of relative paths to matched items
 */
async function findApps(archivePath, appExtensions) {
    const useSystemUnzipEnv = process.env.APPIUM_PREFER_SYSTEM_UNZIP;
    const useSystemUnzip = lodash_1.default.isEmpty(useSystemUnzipEnv)
        || !['0', 'false'].includes(lodash_1.default.toLower(useSystemUnzipEnv));
    const tmpRoot = await support_1.tempDir.openDir();
    await support_1.zip.extractAllTo(archivePath, tmpRoot, { useSystemUnzip });
    const globPattern = `**/*.+(${appExtensions.map((ext) => ext.replace(/^\./, '')).join('|')})`;
    const sortedBundleItems = (await support_1.fs.glob(globPattern, {
        cwd: tmpRoot,
        strict: false,
    })).sort((a, b) => a.split(path_1.default.sep).length - b.split(path_1.default.sep).length);
    return [tmpRoot, sortedBundleItems];
}
exports.findApps = findApps;
/**
 * Moves the application bundle to a newly created temporary folder
 *
 * @param {string} appRoot Full path to the .app bundle
 * @returns {Promise<string>} The new path to the app bundle.
 * The name of the app bundle remains though
 */
async function isolateAppBundle(appRoot) {
    const tmpRoot = await support_1.tempDir.openDir();
    const dstRoot = path_1.default.join(tmpRoot, path_1.default.basename(appRoot));
    await support_1.fs.mv(appRoot, dstRoot, { mkdirp: true });
    return dstRoot;
}
exports.isolateAppBundle = isolateAppBundle;
//# sourceMappingURL=app-utils.js.map