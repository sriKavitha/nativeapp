declare namespace _default {
    /**
     * Get all ConditionInducer configuration information
     * We will use conditionID and profileID in the mobileEnableConditionInducer
     * @returns {Promise<Condition[]>}
     * [{
     *     "profiles": [
     *          {
     *             "name": "100% packet loss",
     *             "identifier": "SlowNetwork100PctLoss",  // MobileEnableConditionInducer profileID
     *             "description": "Name: 100% Loss Scenario\n
     *                             Downlink Bandwidth: 0 Mbps\n
     *                             Downlink Latency:0 ms\n
     *                             Downlink Packet Loss Ratio: 100%\n
     *                             Uplink Bandwidth: 0 Mbps\n
     *                             Uplink Latency: 0 ms\n
     *                             Uplink Packet Loss Ratio: 100%"
     *         }
     *     ],
     *     "profilesSorted": true,
     *     "identifier": "SlowNetworkCondition",    // MobileEnableConditionInducer conditionID
     *     "isDestructive": false,
     *     "isInternal": false,
     *     "activeProfile": "",
     *     "name": "Network Link",
     *     "isActive": false
     * }]
     * @this {XCUITestDriver}
     */
    function listConditionInducers(this: import("../driver").default): Promise<Condition[]>;
    /**
     * Enable a "condition inducer". You can create a condition on a connected device to test your app under adverse conditions,
     * such as poor network connectivity or thermal constraints. When you start a device condition,
     * the operating system on the device behaves as if its environment has changed. The device
     * condition remains active until you stop the device condition or disconnect the device. For
     * example, you can start a device condition, run your app, monitor your appâ€™s energy usage, and
     * then stop the condition.
     *
     * (Note: the socket needs to remain connected during operation)
     * (Note: Device conditions are available only for real devices running iOS 13.0 and later.)
     *
     * @param {string} conditionID - Determine which condition IDs are available with the {@linkcode XCUITestDriver.listConditionInducers} command
     * @param {string} profileID - Determine which profile IDs are available with the {@linkcode XCUITestDriver.listConditionInducers} command
     * @returns {Promise<boolean>} `true` if enabling the condition succeeded
     * @throws {Error} If you try to start another Condition and the previous Condition has not stopped
     * @since 4.9.0
     * @see {@link https://help.apple.com/xcode/mac/current/#/dev308429d42}
     * @this {XCUITestDriver}
     */
    function enableConditionInducer(this: import("../driver").default, conditionID: string, profileID: string): Promise<boolean>;
    /**
     * Disable condition inducer
     * this call upon driver deletion
     * @returns {Promise<boolean>} `true` if disable the condition succeeded
     * @this {XCUITestDriver}
     */
    function disableConditionInducer(this: import("../driver").default): Promise<boolean>;
}
export default _default;
export type Profile = {
    name: string;
    /**
     * the property is profileID used in MobileEnableConditionInducer
     */
    identifier: string;
    /**
     * Configuration details
     */
    description: string;
};
/**
 * We can use the returned data to determine whether the Condition is enabled and the currently enabled configuration information
 */
export type Condition = {
    profiles: Profile[];
    /**
     * the property is conditionID used in MobileEnableConditionInducer
     */
    identifier: string;
    profilesSorted: boolean;
    isDestructive: boolean;
    isInternal: boolean;
    /**
     * `true` if this condition identifier is enabled
     */
    isActive: boolean;
    /**
     * enabled profiles identifier
     */
    activeProfile: string;
};
export type XCUITestDriver = import('../driver').XCUITestDriver;
//# sourceMappingURL=condition.d.ts.map