export class TrafficCapture {
    constructor(udid: any, log: any, resultPath: any);
    /** @type {import('teen_process').SubProcess|null} */
    mainProcess: import('teen_process').SubProcess | null;
    udid: any;
    log: any;
    resultPath: any;
    start(timeoutSeconds: any): Promise<void>;
    isCapturing(): boolean;
    interrupt(force?: boolean): Promise<boolean>;
    finish(): Promise<any>;
    cleanup(): Promise<void>;
}
declare namespace _default {
    /**
     * Records the given network traffic capture into a .pcap file.
     *
     * @param {number} timeLimitSec - The maximum recording time, in seconds. The maximum value is `43200` (12 hours).
     * @param {boolean} forceRestart - Whether to restart traffic capture process forcefully when startPcap is called (`true`) or ignore the call until the current traffic capture is completed (`false`, the default value).
     * @throws {Error} If network traffic capture has failed to start.
     * @returns {Promise<void>}
     * @this {XCUITestDriver}
     */
    function mobileStartPcap(this: import("../driver").default, timeLimitSec?: number, forceRestart?: boolean): Promise<void>;
    /**
     * Stop capture of the device network traffic. If no traffic capture process is running then
     * the endpoint will try to get the recently recorded file.
     * If no previously recorded file is found and no active traffic capture
     * processes are running then the method returns an empty string.
     *
     * @returns {Promise<string>} Base64-encoded content of the recorded pcap file or an
     * empty string if no traffic capture has been started before.
     * @throws {Error} If there was an error while getting the capture file.
     * @this {XCUITestDriver}
     */
    function mobileStopPcap(this: import("../driver").default): Promise<string>;
}
export default _default;
export type XCUITestDriver = import('../driver').XCUITestDriver;
//# sourceMappingURL=pcap.d.ts.map