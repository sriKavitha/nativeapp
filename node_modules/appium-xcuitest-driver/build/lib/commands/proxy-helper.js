"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const driver_1 = require("appium/driver");
const bluebird_1 = __importDefault(require("bluebird"));
const GET = 'GET';
const POST = 'POST';
const DELETE = 'DELETE';
const SUPPORTED_METHODS = Object.freeze(new Set(/** @type {const} */ ([GET, POST, DELETE])));
const WDA_ROUTES = /** @type {const} */ ({
    '/wda/touch/perform': {
        POST: 'performTouch',
    },
    '/wda/touch/multi/perform': {
        POST: 'performMultiAction',
    },
    '/wda/screen': {
        GET: 'getScreenInfo',
    },
    '/wda/alert/buttons': {
        GET: 'getAlertButtons',
    },
    '/wda/apps/launch': {
        POST: 'mobileLaunchApp',
    },
    '/wda/apps/terminate': {
        POST: 'mobileTerminateApp',
    },
    '/wda/apps/activate': {
        POST: 'mobileActivateApp',
    },
    '/wda/apps/state': {
        POST: 'mobileQueryAppState',
    },
    '/wda/keys': {
        POST: 'keys',
    },
    '/wda/touch_id': {
        POST: 'touchId',
    },
    '/wda/keyboard/dismiss': {
        POST: 'hideKeyboard',
    },
    '/wda/lock': {
        POST: 'lock',
    },
    '/wda/unlock': {
        POST: 'unlock',
    },
    '/wda/locked': {
        GET: 'isLocked',
    },
    '/wda/tap/nil': {
        POST: 'clickCoords',
    },
    '/window/size': {
        GET: 'getWindowSize',
    },
});
/**
 * @param {string} endpoint
 * @param {AllowedHttpMethod} method
 * @returns {string|undefined}
 */
function wdaRouteToCommandName(endpoint, method) {
    if (endpoint in WDA_ROUTES) {
        return WDA_ROUTES[endpoint][method];
    }
}
exports.default = {
    /**
     *
     * @param {string} endpoint
     * @param {AllowedHttpMethod} method
     * @param {any} [body]
     * @param {boolean} isSessionCommand
     * @this {import('../driver').XCUITestDriver}
     */
    async proxyCommand(endpoint, method, body, isSessionCommand = true) {
        if (this.shutdownUnexpectedly) {
            return;
        }
        if (!endpoint) {
            this.log.errorAndThrow('Proxying requires an endpoint');
        }
        else if (!SUPPORTED_METHODS.has(method)) {
            this.log.errorAndThrow(`Proxying only works for the following HTTP methods: ${[...SUPPORTED_METHODS].join(', ')}`);
        }
        if (!this.wda) {
            throw new Error('Cannot call proxyCommand without WDA driver active');
        }
        const proxy = isSessionCommand ? this.wda.jwproxy : this.wda.noSessionProxy;
        if (!proxy) {
            throw new Error('Cannot call proxyCommand without WDA proxy active');
        }
        let cmdName = wdaRouteToCommandName(endpoint, method) || (0, driver_1.routeToCommandName)(endpoint, method);
        const timeout = this._getCommandTimeout(cmdName);
        if (!cmdName) {
            // this should never happen except when adding new routes
            cmdName = 'Unknown'; // just for logging purposes below
            this.log.info(`Proxying to WDA with an unknown route: ${method} ${endpoint}`);
        }
        if (!timeout) {
            return await proxy.command(endpoint, method, body);
        }
        this.log.debug(`Setting custom timeout to ${timeout} ms for '${cmdName}' command`);
        let isCommandExpired = false;
        const res = await bluebird_1.default.resolve(proxy.command(endpoint, method, body))
            .timeout(timeout)
            .catch(bluebird_1.default.Promise.TimeoutError, () => {
            isCommandExpired = true;
        });
        if (isCommandExpired) {
            proxy.cancelActiveRequests();
            const errMsg = `Appium did not get any response from '${cmdName}' command in ${timeout} ms`;
            await this.startUnexpectedShutdown(new driver_1.errors.TimeoutError(errMsg));
            this.log.errorAndThrow(errMsg);
        }
        return res;
    },
};
/**
 * @typedef {import('../driver').XCUITestDriver} XCUITestDriver
 * @typedef {'GET'|'POST'|'DELETE'} AllowedHttpMethod
 */
//# sourceMappingURL=proxy-helper.js.map