"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pushFolder = exports.pushFile = exports.pullFolder = exports.pullFile = void 0;
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const support_1 = require("appium/support");
const path_1 = __importDefault(require("path"));
const logger_1 = __importDefault(require("./logger"));
const IO_TIMEOUT_MS = 4 * 60 * 1000;
// Mobile devices use NAND memory modules for the storage,
// and the parallelism there is not as performant as on regular SSDs
const MAX_IO_CHUNK_SIZE = 8;
/**
 * Retrieve a file from a real device
 *
 * @param {any} afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param {string} remotePath Relative path to the file on the device
 * @returns {Promise<Buffer>} The file content as a buffer
 */
async function pullFile(afcService, remotePath) {
    const stream = await afcService.createReadStream(remotePath, { autoDestroy: true });
    const pullPromise = new bluebird_1.default((resolve, reject) => {
        stream.on('close', resolve);
        stream.on('error', reject);
    }).timeout(IO_TIMEOUT_MS);
    const buffers = [];
    stream.on('data', (data) => buffers.push(data));
    await pullPromise;
    return Buffer.concat(buffers);
}
exports.pullFile = pullFile;
/**
 * Checks a presence of a local folder.
 *
 * @param {string} folderPath Full path to the local folder
 * @returns {Promise<boolean>} True if the folder exists and is actually a folder
 */
async function folderExists(folderPath) {
    try {
        return (await support_1.fs.stat(folderPath)).isDirectory();
    }
    catch (e) {
        return false;
    }
}
/**
 * Retrieve a folder from a real device
 *
 * @param {any} afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param {string} remoteRootPath Relative path to the folder on the device
 * @returns {Promise<Buffer>} The folder content as a zipped base64-encoded buffer
 */
async function pullFolder(afcService, remoteRootPath) {
    const tmpFolder = await support_1.tempDir.openDir();
    try {
        let localTopItem = null;
        let countFilesSuccess = 0;
        let countFilesFail = 0;
        let countFolders = 0;
        const pullPromises = [];
        await afcService.walkDir(remoteRootPath, true, async (remotePath, isDir) => {
            const localPath = path_1.default.join(tmpFolder, remotePath);
            const dirname = isDir ? localPath : path_1.default.dirname(localPath);
            if (!await folderExists(dirname)) {
                await (0, support_1.mkdirp)(dirname);
            }
            if (!localTopItem
                || localPath.split(path_1.default.sep).length < localTopItem.split(path_1.default.sep).length) {
                localTopItem = localPath;
            }
            if (isDir) {
                ++countFolders;
                return;
            }
            const readStream = await afcService.createReadStream(remotePath, { autoDestroy: true });
            const writeStream = support_1.fs.createWriteStream(localPath, { autoClose: true });
            pullPromises.push(new bluebird_1.default((resolve) => {
                writeStream.on('close', () => {
                    ++countFilesSuccess;
                    resolve();
                });
                const onStreamingError = (e) => {
                    readStream.unpipe(writeStream);
                    logger_1.default.warn(`Cannot pull '${remotePath}' to '${localPath}'. ` +
                        `The file will be skipped. Original error: ${e.message}`);
                    ++countFilesFail;
                    resolve();
                };
                writeStream.on('error', onStreamingError);
                readStream.on('error', onStreamingError);
            }).timeout(IO_TIMEOUT_MS));
            readStream.pipe(writeStream);
            if (pullPromises.length >= MAX_IO_CHUNK_SIZE) {
                await bluebird_1.default.any(pullPromises);
            }
            lodash_1.default.remove(pullPromises, (p) => p.isFulfilled());
        });
        // Wait for the rest of files to be pulled
        if (!lodash_1.default.isEmpty(pullPromises)) {
            await bluebird_1.default.all(pullPromises);
        }
        logger_1.default.info(`Pulled ${support_1.util.pluralize('file', countFilesSuccess, true)} out of ` +
            `${countFilesSuccess + countFilesFail} and ${support_1.util.pluralize('folder', countFolders, true)} ` +
            `from '${remoteRootPath}'`);
        return await support_1.zip.toInMemoryZip(localTopItem ? path_1.default.dirname(localTopItem) : tmpFolder, {
            encodeToBase64: true,
        });
    }
    finally {
        await support_1.fs.rimraf(tmpFolder);
    }
}
exports.pullFolder = pullFolder;
/**
 * Creates remote folder path recursively. Noop if the given path
 * already exists
 *
 * @param {any} afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param {string} remoteRoot The relative path to the remote folder structure
 * to be created
 */
async function remoteMkdirp(afcService, remoteRoot) {
    if (remoteRoot === '.' || remoteRoot === '/') {
        return;
    }
    try {
        await afcService.listDirectory(remoteRoot);
        return;
    }
    catch (e) {
        // This means that the directory is missing and we got an object not found error.
        // Therefore, we are going to the parent
        await remoteMkdirp(afcService, path_1.default.dirname(remoteRoot));
    }
    await afcService.createDirectory(remoteRoot);
}
/**
 * Pushes a file to a real device
 *
 * @param {any} afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param {string} remotePath Relative path to the file on the device. The remote
 * folder structure is created automatically if necessary.
 * @param {string} base64Data Base64-encoded content of the file to be written
 */
async function pushFile(afcService, remotePath, base64Data) {
    await remoteMkdirp(afcService, path_1.default.dirname(remotePath));
    const stream = await afcService.createWriteStream(remotePath, { autoDestroy: true });
    let pushError = null;
    const pushPromise = new bluebird_1.default((resolve, reject) => {
        stream.on('error', (e) => {
            pushError = e;
        });
        stream.on('close', () => {
            if (pushError) {
                reject(pushError);
            }
            else {
                resolve();
            }
        });
    }).timeout(IO_TIMEOUT_MS);
    stream.write(Buffer.from(base64Data, 'base64'));
    stream.end();
    await pushPromise;
}
exports.pushFile = pushFile;
/**
 * @typedef {Object} PushFolderOptions
 *
 * @property {number} [timeoutMs=240000] The maximum timeout to wait until a
 * single file is copied
 * @property {boolean} [enableParallelPush=false] Whether to push files in parallel.
 * This usually gives better performance, but might sometimes be less stable.
 */
/**
 * Pushes a folder to a real device
 *
 * @param {any} afcService Apple File Client service instance from
 * 'appium-ios-device' module
 * @param {string} srcRootPath The full path to the source folder
 * @param {string} dstRootPath The relative path to the destination folder. The folder
 * will be deleted if already exists.
 * @param {PushFolderOptions} opts
 */
async function pushFolder(afcService, srcRootPath, dstRootPath, opts = {}) {
    const { timeoutMs = IO_TIMEOUT_MS, enableParallelPush = false, } = opts;
    const timer = new support_1.timing.Timer().start();
    const itemsToPush = await support_1.fs.glob('**', {
        cwd: srcRootPath,
        nosort: true,
        mark: true,
    });
    logger_1.default.debug(`Successfully scanned the tree structure of '${srcRootPath}'`);
    const [foldersToPush, filesToPush] = itemsToPush.reduce((acc, x) => {
        acc[lodash_1.default.endsWith(x, path_1.default.sep) ? 0 : 1].push(x);
        return acc;
    }, /** @type {[string[], string[]]} */ ([[], []]));
    logger_1.default.debug(`Got ${support_1.util.pluralize('folder', foldersToPush.length, true)} and ` +
        `${support_1.util.pluralize('file', filesToPush.length, true)} to push`);
    // create the folder structure first
    try {
        await afcService.deleteDirectory(dstRootPath);
    }
    catch (ign) { }
    await afcService.createDirectory(dstRootPath);
    // top-level folders must go first
    const foldersToPushByHierarchy = foldersToPush
        .sort((a, b) => a.split(path_1.default.sep).length - b.split(path_1.default.sep).length);
    for (const relativeFolderPath of foldersToPushByHierarchy) {
        // createDirectory does not accept folder names ending with a path separator
        const absoluteFolderPath = lodash_1.default.trimEnd(path_1.default.join(dstRootPath, relativeFolderPath), path_1.default.sep);
        if (absoluteFolderPath) {
            await afcService.createDirectory(absoluteFolderPath);
        }
    }
    // do not forget about the root folder
    logger_1.default.debug(`Successfully created the remote folder structure ` +
        `(${support_1.util.pluralize('item', foldersToPush.length + 1, true)})`);
    const pushFile = async (relativePath) => {
        const absoluteSourcePath = path_1.default.join(srcRootPath, relativePath);
        const readStream = support_1.fs.createReadStream(absoluteSourcePath, { autoClose: true });
        const absoluteDestinationPath = path_1.default.join(dstRootPath, relativePath);
        const writeStream = await afcService.createWriteStream(absoluteDestinationPath, {
            autoDestroy: true
        });
        writeStream.on('finish', writeStream.destroy);
        let pushError = null;
        const filePushPromise = new bluebird_1.default((resolve, reject) => {
            writeStream.on('close', () => {
                if (pushError) {
                    reject(pushError);
                }
                else {
                    resolve();
                }
            });
            const onStreamError = (e) => {
                readStream.unpipe(writeStream);
                logger_1.default.debug(e);
                pushError = e;
            };
            writeStream.on('error', onStreamError);
            readStream.on('error', onStreamError);
        });
        readStream.pipe(writeStream);
        await filePushPromise.timeout(timeoutMs);
    };
    if (enableParallelPush) {
        logger_1.default.debug(`Proceeding to parallel files push (max ${MAX_IO_CHUNK_SIZE} writers)`);
        const pushPromises = [];
        for (const relativeFilePath of lodash_1.default.shuffle(filesToPush)) {
            pushPromises.push(bluebird_1.default.resolve(pushFile(relativeFilePath)));
            // keep the push queue filled
            if (pushPromises.length >= MAX_IO_CHUNK_SIZE) {
                await bluebird_1.default.any(pushPromises);
            }
            lodash_1.default.remove(pushPromises, (p) => p.isFulfilled());
        }
        if (!lodash_1.default.isEmpty(pushPromises)) {
            // handle the rest of push promises
            await bluebird_1.default.all(pushPromises);
        }
    }
    else {
        logger_1.default.debug(`Proceeding to serial files push`);
        for (const relativeFilePath of filesToPush) {
            await pushFile(relativeFilePath);
        }
    }
    logger_1.default.debug(`Successfully pushed ${support_1.util.pluralize('folder', foldersToPush.length, true)} ` +
        `and ${support_1.util.pluralize('file', filesToPush.length, true)} ` +
        `within ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
}
exports.pushFolder = pushFolder;
//# sourceMappingURL=ios-fs-helpers.js.map