"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const support_1 = require("appium/support");
const path_1 = __importDefault(require("path"));
const appium_ios_device_1 = require("appium-ios-device");
const bluebird_1 = __importDefault(require("bluebird"));
const logger_1 = __importDefault(require("./logger"));
const lodash_1 = __importDefault(require("lodash"));
const teen_process_1 = require("teen_process");
const app_utils_1 = require("./app-utils");
const ios_fs_helpers_1 = require("./ios-fs-helpers");
const APPLICATION_INSTALLED_NOTIFICATION = 'com.apple.mobile.application_installed';
const INSTALLATION_STAGING_DIR = 'PublicStaging';
const APPLICATION_NOTIFICATION_TIMEOUT_MS = 30 * 1000;
const IOS_DEPLOY_TIMEOUT_MS = 4 * 60 * 1000;
const IOS_DEPLOY = 'ios-deploy';
const APP_INSTALL_STRATEGY = Object.freeze({
    SERIAL: 'serial',
    PARALLEL: 'parallel',
    IOS_DEPLOY,
});
class IOSDeploy {
    constructor(udid) {
        this.udid = udid;
    }
    async remove(bundleId) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            await service.uninstallApplication(bundleId);
        }
        finally {
            service.close();
        }
    }
    async removeApp(bundleId) {
        await this.remove(bundleId);
    }
    /**
     *
     * @param {string} app
     * @param {number} [timeout]
     * @param {'ios-deploy'|'serial'|'parallel'|null} strategy
     * @privateRemarks This really needs type guards built out
     */
    async install(app, timeout, strategy = null) {
        if (strategy && !lodash_1.default.values(APP_INSTALL_STRATEGY).includes(/** @type {any} */ (lodash_1.default.toLower(strategy)))) {
            throw new Error(`App installation strategy '${strategy}' is unknown. ` +
                `Only the following strategies are supported: ${lodash_1.default.values(APP_INSTALL_STRATEGY)}`);
        }
        logger_1.default.debug(`Using '${strategy ?? APP_INSTALL_STRATEGY.SERIAL}' app deployment strategy. ` +
            `You could change it by providing another value to the 'appInstallStrategy' capability`);
        const installWithIosDeploy = async () => {
            try {
                await support_1.fs.which(IOS_DEPLOY);
            }
            catch (err) {
                throw new Error(`'${IOS_DEPLOY}' utility has not been found in PATH. Is it installed?`);
            }
            try {
                await (0, teen_process_1.exec)(IOS_DEPLOY, ['--id', this.udid, '--bundle', app], {
                    timeout: timeout ?? IOS_DEPLOY_TIMEOUT_MS,
                });
            }
            catch (err) {
                throw new Error(err.stderr || err.stdout || err.message);
            }
        };
        const timer = new support_1.timing.Timer().start();
        if (lodash_1.default.toLower(/** @type {'ios-deploy'} */ (strategy)) === APP_INSTALL_STRATEGY.IOS_DEPLOY) {
            await installWithIosDeploy();
        }
        else {
            const afcService = await appium_ios_device_1.services.startAfcService(this.udid);
            try {
                const bundleId = await (0, app_utils_1.extractBundleId)(app);
                const bundlePathOnPhone = path_1.default.join(INSTALLATION_STAGING_DIR, bundleId);
                await (0, ios_fs_helpers_1.pushFolder)(afcService, app, bundlePathOnPhone, {
                    timeoutMs: timeout,
                    enableParallelPush: lodash_1.default.toLower(/** @type {'parallel'} */ (strategy)) === APP_INSTALL_STRATEGY.PARALLEL,
                });
                await this.installOrUpgradeApplication(bundlePathOnPhone, await this.isAppInstalled(bundleId));
            }
            catch (err) {
                logger_1.default.warn(`Error installing app '${app}': ${err.message}`);
                if (err instanceof bluebird_1.default.TimeoutError) {
                    logger_1.default.warn(`Consider increasing the value of 'appPushTimeout' capability`);
                }
                logger_1.default.warn(`Falling back to '${IOS_DEPLOY}' usage`);
                try {
                    await installWithIosDeploy();
                }
                catch (err1) {
                    throw new Error(`Could not install '${app}':\n` + `  - ${err.message}\n` + `  - ${err1.message}`);
                }
            }
            finally {
                afcService.close();
            }
        }
        logger_1.default.info(`App installation succeeded after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`);
    }
    async installOrUpgradeApplication(bundlePathOnPhone, isUpgrade = false) {
        const notificationService = await appium_ios_device_1.services.startNotificationProxyService(this.udid);
        const installationService = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        const appInstalledNotification = new bluebird_1.default((resolve) => {
            notificationService.observeNotification(APPLICATION_INSTALLED_NOTIFICATION, {
                notification: resolve,
            });
        });
        const clientOptions = { PackageType: 'Developer' };
        try {
            if (isUpgrade) {
                logger_1.default.debug(`An upgrade of the existing application is going to be performed`);
                await installationService.upgradeApplication(bundlePathOnPhone, clientOptions);
            }
            else {
                logger_1.default.debug(`A new application installation is going to be performed`);
                await installationService.installApplication(bundlePathOnPhone, clientOptions);
            }
            try {
                await appInstalledNotification.timeout(APPLICATION_NOTIFICATION_TIMEOUT_MS, `Could not get the application installed notification within ` +
                    `${APPLICATION_NOTIFICATION_TIMEOUT_MS}ms but we will continue`);
            }
            catch (e) {
                logger_1.default.warn(`Failed to receive the notification. Error: ${e.message}`);
            }
        }
        finally {
            installationService.close();
            notificationService.close();
        }
    }
    /**
     * Alias for {@linkcode install}
     * @param {string} app
     * @param {number} timeout
     * @param {'ios-deploy'|'serial'|'parallel'|null} strategy
     */
    async installApp(app, timeout, strategy) {
        return await this.install(app, timeout, strategy);
    }
    /**
     * Return an application object if test app has 'bundleid'.
     * The target bundleid can be User and System apps.
     * @param {string} bundleId The bundleId to ensure it is installed
     * @return {Promise<boolean>} Returns True if the bundleid exists in the result of 'listApplications' like:
     * { "com.apple.Preferences":{
     *   "UIRequiredDeviceCapabilities":["arm64"],
     *   "UIRequiresFullScreen":true,
     *   "CFBundleInfoDictionaryVersion":"6.0",
     *   "Entitlements":
     *     {"com.apple.frontboard.delete-application-snapshots":true,..
     */
    async isAppInstalled(bundleId) {
        return Boolean(await this.fetchAppInfo(bundleId));
    }
    async fetchAppInfo(bundleId) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            return (await service.lookupApplications({ bundleIds: bundleId }))[bundleId];
        }
        finally {
            service.close();
        }
    }
    async terminateApp(bundleId) {
        let instrumentService;
        let installProxyService;
        try {
            installProxyService = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
            const apps = await installProxyService.listApplications();
            if (!apps[bundleId]) {
                logger_1.default.info(`The bundle id '${bundleId}' did not exist`);
                return false;
            }
            const executableName = apps[bundleId].CFBundleExecutable;
            logger_1.default.debug(`The executable name for the bundle id '${bundleId}' was '${executableName}'`);
            instrumentService = await appium_ios_device_1.services.startInstrumentService(this.udid);
            const processes = await instrumentService.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.DEVICE_INFO, 'runningProcesses');
            const process = processes.selector.find((process) => process.name === executableName);
            if (!process) {
                logger_1.default.info(`The process of the bundle id '${bundleId}' was not running`);
                return false;
            }
            await instrumentService.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.PROCESS_CONTROL, 'killPid:', `${process.pid}`);
            return true;
        }
        catch (err) {
            logger_1.default.warn(`Failed to kill '${bundleId}'. Original error: ${err.stderr || err.message}`);
            return false;
        }
        finally {
            if (installProxyService) {
                installProxyService.close();
            }
            if (instrumentService) {
                instrumentService.close();
            }
        }
    }
    /**
     * @param {string} bundleName The name of CFBundleName in Info.plist
     *
     * @returns {Promise<string[]>} A list of User level apps' bundle ids which has
     *                          'CFBundleName' attribute as 'bundleName'.
     */
    async getUserInstalledBundleIdsByBundleName(bundleName) {
        const service = await appium_ios_device_1.services.startInstallationProxyService(this.udid);
        try {
            const applications = await service.listApplications({ applicationType: 'User' });
            return lodash_1.default.reduce(applications, (acc, { CFBundleName }, key) => {
                if (CFBundleName === bundleName) {
                    acc.push(key);
                }
                return acc;
            }, 
            /** @type {string[]} */ ([]));
        }
        finally {
            service.close();
        }
    }
    async getPlatformVersion() {
        return await appium_ios_device_1.utilities.getOSVersion(this.udid);
    }
}
exports.default = IOSDeploy;
//# sourceMappingURL=ios-deploy.js.map